# Code_Idea

**Generated**: 2025-12-30T11:02:05.533228
**Novelty Score**: 1.00
**Source File**: /home/josh/str/projects/codedreamer/codedreamer/graph.py

---

 ### 1. Current State Assessment

- **What is this code doing?**
  - The `connect_related_nodes` method in the `KnowledgeGraph` class automatically connects a node to related existing nodes based on two criteria: same source file and temporal proximity.
  - It creates edges with specific relation types ("same_file" and "same_cycle") and ensures that no duplicate edges are created.

- **What patterns/paradigms is it using?**
  - The method uses list comprehensions to filter nodes based on the criteria.
  - It sorts nodes by relevance (momentum for same-file, time proximity for same-cycle) before creating edges.
  - It avoids creating duplicate edges by checking if an edge already exists in the graph.

### 2. Identified Issues

1. **Hardcoded Weights**
   - **Line**: `self.add_edge(node_id, target.id, "same_file", weight=0.8)` and `self.add_edge(node_id, target.id, "same_cycle", weight=0.5)`
   - **Why**: Hardcoding weights makes the method less flexible. If different use cases require different weights, the code will need to be modified.
   - **Impact**: Reduces maintainability and adaptability.

2. **Redundant Node Filtering**
   - **Lines**: `same_file_nodes = [n for n in self._nodes.values() if n.id != node_id and (n.metadata.get("source") == source_file or n.metadata.get("source_file") == source_file)]` and `temporal_nodes = [n for n in self._nodes.values() if n.id != node_id and abs(n.created_at - node_time) <= temporal_window_sec]`
   - **Why**: Filtering nodes twice (once for same-file and once for temporal proximity) can be inefficient, especially as the number of nodes grows.
   - **Impact**: Potential performance degradation.

3. **Duplicate Edge Check**
   - **Lines**: `if not self._graph.has_edge(node_id, target.id):`
   - **Why**: Checking for duplicate edges in a loop can be costly, especially if the graph is large.
   - **Impact**: Performance overhead and potential scalability issues.

4. **Lack of Configurability**
   - **Lines**: `max_edges: int = 5` and `temporal_window_sec: float = 300.0`
   - **Why**: These parameters are set as defaults but could benefit from being configurable via the class or a configuration file.
   - **Impact**: Reduced flexibility and adaptability.

5. **Logging Granularity**
   - **Line**: `logger.debug(f"Auto-connected {node_id}: {edges_created} edges created")`
   - **Why**: The logging statement provides minimal information and could be more detailed to aid in debugging and monitoring.
   - **Impact**: Reduced visibility into the method's operations.

### 3. Proposed Improvement

1. **Parameterize Weights**
   - Introduce a configuration file or class attributes for weights.
   - This allows for different use cases without modifying the code directly.
   - **Example**:
     ```python
     self.add_edge(node_id, target.id, "same_file", weight=self.config['same_file_weight'])
     self.add_edge(node_id, target.id, "same_cycle", weight=self.config['same_cycle_weight'])
     ```

2. **Optimize Node Filtering**
   - Combine the filtering logic to avoid redundant iterations.
   - Use a set to store node IDs that meet the criteria and then filter out duplicates in a single pass.
   - **Example**:
     ```python
     related_nodes = {
         n.id for n in self._nodes.values()
         if n.id != node_id and (
             (source_file and (n.metadata.get("source") == source_file or n.metadata.get("source_file") == source_file)) or
             abs(n.created_at - node_time) <= temporal_window_sec
         )
     }
     ```

3. **Batch Edge Creation**
   - Create a batch of edges to reduce the number of duplicate edge checks.
   - This can be done by first collecting all potential edges and then filtering out duplicates in one go.
   - **Example**:
     ```python
     edges_to_add = []
     for target_id in related_nodes:
         if not self._graph.has_edge(node_id, target_id):
             relation = "same_file" if any(n.metadata.get("source") == source_file or n.metadata.get("source_file") == source_file for n in self._nodes.values() if n.id == target_id) else "same_cycle"
             edges_to_add.append((node_id, target_id, relation))
     for edge in edges_to_add:
         self.add_edge(*edge)
     ```

4. **Make Parameters Configurable**
   - Move default parameters to a configuration file or class attributes.
   - This allows for easier customization without modifying the method signature.
   - **Example**:
     ```python
     def connect_related_nodes(
         self,
         node_id: str,
         max_edges: int = None,
         temporal_window_sec: float = None,
     ) -> int:
         max_edges = max_edges or self.config['max_edges']
         temporal_window_sec = temporal_window_sec or self.config['temporal_window_sec']
     ```

5. **Enhance Logging**
   - Provide more detailed logging to aid in debugging and monitoring.
   - Include information about the criteria used for each edge created.
   - **Example**:
     ```python
     logger.debug(f"Auto-connected {node_id}: {edges_created} edges created. Criteria: same_file={len(same_file_nodes)}, same_cycle={len(temporal_nodes)}")
     ```

### 4. Implementation Strategy

1. **Step-by-Step Approach**
   - **Step 1**: Create a configuration file or class attributes for weights and default parameters.
     ```python
     class KnowledgeGraph:
         def __init__(self, config=None):
             self.config = {
                 'same_file_weight': 0.8,
                 'same_cycle_weight': 0.5,
                 'max_edges': 5,
                 'temporal_window_sec': 300.0,
             }
             if config:
                 self.config.update(config)
     ```
   - **Step 2**: Modify the `connect_related_nodes` method to use configurable parameters and weights.
     ```python
     def connect_related_nodes(
         self,
         node_id: str,
         max_edges: int = None,
         temporal_window_sec: float = None,
     ) -> int:
         max_edges = max_edges or self.config['max_edges']
         temporal_window_sec = temporal_window_sec or self.config['temporal_window_sec']

         node = self._nodes.get(node_id)
         if not node:
             return 0

         edges_created = 0
         source_file = node.metadata.get("source") or node.metadata.get("source_file")

         related_nodes = {
             n.id for n in self._nodes.values()
             if n.id != node_id and (
                 (source_file and (n.metadata.get("source") == source_file or n.metadata.get("source_file") == source_file)) or
                 abs(n.created_at - node_time) <= temporal_window_sec
             )
         }

         edges_to_add = []
         for target_id in related_nodes:
             if not self._graph.has_edge(node_id, target_id):
                 relation = "same_file" if any(n.metadata.get("source") == source_file or n.metadata.get("source_file") == source_file for n in self._nodes.values() if n.id == target_id) else "same_cycle"
                 edges_to_add.append((node_id, target_id, relation))

         for edge in edges_to_add[:max_edges]:
             self.add_edge(*edge)
             edges_created += 1

         logger.debug(f"Auto-connected {node_id}: {edges_created} edges created. Criteria: same_file={len(same_file_nodes)}, same_cycle={len(temporal_nodes)}")

         return edges_created
     ```

2. **Tests to Validate the Change**
   - **Test Configuration Parameters**:
     - Ensure that default parameters are used when none are provided.
     - Verify that custom parameters override defaults.
   - **Test Node Filtering and Edge Creation**:
     - Create a set of nodes with known metadata and creation times.
     - Call `connect_related_nodes` and verify that the correct edges are created based on the criteria.
   - **Test Performance**:
     - Measure the time taken to connect nodes with a large number of nodes.
     - Compare performance before and after optimization.
   - **Test Logging**:
     - Check that the debug log contains detailed information about the edges created and the criteria used.

By implementing these changes, the `connect_related_nodes` method will be more flexible, efficient, and maintainable. ### 5. Additional Considerations

- **Future Enhancements**: As mentioned in the docstring, future enhancements like semantic similarity via embeddings and concept co-occurrence analysis can be added as new relation types.
- **Error Handling**: Add error handling for edge cases such as invalid node IDs or missing metadata.
- **Documentation**: Update the method's docstring to reflect the changes and provide examples of how to use the configurable parameters. ### 6. Conclusion

The proposed improvements aim to make the `connect_related_nodes` method more robust, efficient, and adaptable to different use cases. By parameterizing weights, optimizing node filtering, batching edge creation, making parameters configurable, and enhancing logging, we can significantly improve the method's performance and maintainability. Implementing these changes will also pave the way for future enhancements and better scalability.

## Suggested Implementation

```python

class KnowledgeGraph:
    def connect_related_nodes(
        self,
        node_id: str,
        max_edges: int = 5,
        temporal_window_sec: float = 300.0,
        same_file_weight: float = 0.8,
        same_cycle_weight: float = 0.5,
    ) -> int:
        """
        Automatically connect a node to related existing nodes.

        Creates edges based on:
        1. Same source file (relation: "same_file")
        2. Temporal proximity - created within window (relation: "same_cycle")

        Args:
            node_id: The node to connect.
            max_edges: Maximum edges to create per relation type.
            temporal_window_sec: Time window for same-cycle detection.
            same_file_weight: Weight for same-file edges.
            same_cycle_weight: Weight for same-cycle edges.

        Returns:
            Number of edges created.
        """
        node = self._nodes.get(node_id)
        if not node:
            return 0

        edges_created = 0
        source_file = node.metadata.get("source") or node.metadata.get("source_file")

        # 1. Same-file edges: connect nodes that reference the same source file
        if source_file:
            same_file_nodes = [
                n for n in self._nodes.values()
                if n.id != node_id
                and (n.metadata.get("source") == source_file
                     or n.metadata.get("source_file") == source_file)
            ]
            # Sort by momentum (connect to most relevant first)
            same_file_nodes.sort(key=lambda n: n.momentum, reverse=True)

            for target in same_file_nodes[:max_edges]:
                # Avoid duplicate edges
                if not self._graph.has_edge(node_id, target.id):
                    self.add_edge(node_id, target.id, "same_file", weight=same_file_weight)
                    edges_created += 1

        # 2. Same-cycle edges: connect nodes created close in time
        node_time = node.created_at
        temporal_nodes = [
            n for n in self._nodes.values()
            if n.id != node_id
            and abs(n.created_at - node_time) <= temporal_window_sec
        ]
        # Sort by time proximity
        temporal_nodes.sort(key=lambda n: abs(n.created_at - node_time))

        for target in temporal_nodes[:max_edges]:
            # Avoid duplicate edges (might already be connected via same_file)
            if not self._graph.has_edge(node_id, target.id):
                self.add_edge(node_id, target.id, "same_cycle", weight=same_cycle_weight)
                edges_created += 1

        if edges_created > 0:
            logger.debug(f"Auto-connected {node_id}: {edges_created} edges created")

        return edges_created
```
```python
class KnowledgeGraph:
    def connect_related_nodes(
        self,
        node_id: str,
        max_edges: int = 5,
        temporal_window_sec: float = 300.0,
        same_file_weight: float = 0.8,
        same_cycle_weight: float = 0.5,
    ) -> int:
        """
        Automatically connect a node to related existing nodes.

        Creates edges based on:
        1. Same source file (relation: "same_file")
        2. Temporal proximity - created within window (relation: "same_cycle")

        Args:
            node_id: The node to connect.
            max_edges: Maximum edges to create per relation type.
            temporal_window_sec: Time window for same-cycle detection.
            same_file_weight: Weight for same-file edges.
            same_cycle_weight: Weight for same-cycle edges.

        Returns:
            Number of edges created.
        """
        node = self._nodes.get(node_id)
        if not node:
            return 0

        edges_created = 0
        source_file = node.metadata.get("source") or node.metadata.get("source_file")

        # 1. Same-file edges: connect nodes that reference the same source file
        if source_file:
            same_file_nodes = [
                n for n in self._nodes.values()
                if n.id != node_id
                and (n.metadata.get("source") == source_file
                     or n.metadata.get("source_file") == source_file)
            ]
            # Sort by momentum (connect to most relevant first)
            same_file_nodes.sort(key=lambda n: n.momentum, reverse=True)

            for target in same_file_nodes[:max_edges]:
                # Avoid duplicate edges
                if not self._graph.has_edge(node_id, target.id):
                    self.add_edge(node_id, target.id, "same_file", weight=same_file_weight)
                    edges_created += 1

        # 2. Same-cycle edges: connect nodes created close in time
        node_time = node.created_at
        temporal_nodes = [
            n for n in self._nodes.values()
            if n.id != node_id
            and abs(n.created_at - node_time) <= temporal_window_sec
        ]
        # Sort by time proximity
        temporal_nodes.sort(key=lambda n: abs(n.created_at - node_time))

        for target in temporal_nodes[:max_edges]:
            # Avoid duplicate edges (might already be connected via same_file)
            if not self._graph.has_edge(node_id, target.id):
                self.add_edge(node_id, target.id, "same_cycle", weight=same_cycle_weight)
                edges_created += 1

        if edges_created > 0:
            logger.debug(f"Auto-connected {node_id}: {edges_created} edges created")

        return edges_created
```
```

---

## Seed Context

```
# method: KnowledgeGraph.connect_related_nodes
# Automatically connect a node to related existing nodes.

Creates edges based on:
1. Same source file (relation: "same_file")
2. Temporal proximity - created within window (relation: "same_cycle")

Fut
    def connect_related_nodes(
        self,
        node_id: str,
        max_edges: int = 5,
        temporal_window_sec: float = 300.0,
    ) -> int:
        """
        Automatically connect a node to related existing nodes.

        Creates edge
```
